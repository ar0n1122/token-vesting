# Bumps in Solana PDAs - Complete Technical Guide

## Table of Contents

1. [Introduction to PDAs and Bumps](#introduction-to-pdas-and-bumps)
2. [Mathematical Foundation](#mathematical-foundation)
3. [The Canonical Bump Concept](#the-canonical-bump-concept)
4. [Why Store Bumps in Accounts](#why-store-bumps-in-accounts)
5. [The Chicken-and-Egg Problem](#the-chicken-and-egg-problem)
6. [Bump Grinding Attacks](#bump-grinding-attacks)
7. [Security Best Practices](#security-best-practices)
8. [Implementation Patterns](#implementation-patterns)
9. [Common Pitfalls and Solutions](#common-pitfalls-and-solutions)
10. [Real-World Examples](#real-world-examples)

## Introduction to PDAs and Bumps

### What are Program Derived Addresses (PDAs)?

Program Derived Addresses are deterministic addresses generated by Solana programs. Unlike regular wallet addresses that have corresponding private keys, PDAs are controlled entirely by the program that created them.

### What is a Bump?

A **bump** is a single byte (0-255) that is added to the seed array when generating a PDA. It ensures the resulting address falls **off the ed25519 curve**, making it impossible for anyone to have a private key for that address.

### Basic PDA Generation

```rust
// Seeds define the "family" of addresses
let seeds = &[b"employee_vesting", beneficiary.key().as_ref(), vesting_account.key().as_ref()];

// Bump determines the specific address within that family
let (pda, bump) = Pubkey::find_program_address(seeds, &program_id);

// The bump is typically a number like 254, 253, 251, etc.
```

## Mathematical Foundation

### How PDA Generation Works

1. **Combine seeds with bump**: `[seeds..., [bump]]`
2. **Hash the combination**: `sha256(seeds + [bump] + program_id)`
3. **Check if result is on ed25519 curve**: If yes, try next bump (bump - 1)
4. **Return first valid result**: When hash is off the curve

### Why Multiple Bumps Can Be Valid

```rust
// Example: These might all generate valid PDAs
let pda_254 = create_program_address(&[seeds, &[254]], program_id); // ✅ Valid
let pda_253 = create_program_address(&[seeds, &[253]], program_id); // ✅ Valid
let pda_251 = create_program_address(&[seeds, &[251]], program_id); // ✅ Valid
let pda_240 = create_program_address(&[seeds, &[240]], program_id); // ✅ Valid

// Each bump creates a DIFFERENT address!
// pda_254 ≠ pda_253 ≠ pda_251 ≠ pda_240
```

### The Search Process

```rust
// Anchor's find_program_address does this internally:
for bump in (0..=255).rev() { // Start from 255, go down
    if let Ok(pda) = Pubkey::create_program_address(&[seeds, &[bump]], program_id) {
        return (pda, bump); // Return the FIRST (highest) valid bump
    }
}
```

## The Canonical Bump Concept

### Definition

The **canonical bump** is the highest valid bump value that generates a valid PDA for given seeds. Anchor's `find_program_address` always returns this canonical bump.

### Why Canonical Matters

```rust
// Canonical bump (what Anchor uses)
let (canonical_pda, canonical_bump) = Pubkey::find_program_address(seeds, program_id);
// canonical_bump might be 254

// Alternative bumps (security risk)
let alternative_pda = Pubkey::create_program_address(&[seeds, &[251]], program_id);
// Different address, same seeds!
```

### Anchor's Automatic Bump Handling

```rust
#[account(
    init,
    seeds = [b"employee_vesting", beneficiary.key().as_ref()],
    bump // ← Anchor automatically finds canonical bump
)]
pub employee_account: Account<'info, EmployeeAccount>,

// Access the bump Anchor found
let canonical_bump = ctx.bumps.employee_account;
```

## Why Store Bumps in Accounts

### Reason 1: Security Validation

```rust
pub fn claim_tokens(ctx: Context<ClaimTokens>, provided_bump: u8) -> Result<()> {
    // Validate provided bump matches stored canonical bump
    require_eq!(
        provided_bump,
        ctx.accounts.employee_account.bump,
        ErrorCode::InvalidBump
    );
    // Now we know we're using the legitimate account
}
```

### Reason 2: Efficiency in Future Operations

```rust
// Without stored bump - EXPENSIVE
let (pda, bump) = Pubkey::find_program_address(seeds, program_id);

// With stored bump - CHEAP
let pda = Pubkey::create_program_address(&[seeds, &[stored_bump]], program_id)?;
```

### Reason 3: PDA Signing Capability

```rust
pub fn transfer_tokens(ctx: Context<Transfer>) -> Result<()> {
    let seeds = &[
        b"employee_vesting",
        ctx.accounts.employee_account.beneficiary.as_ref(),
        ctx.accounts.employee_account.vesting_account.as_ref(),
        &[ctx.accounts.employee_account.bump] // ← Use stored bump for signing
    ];

    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            transfer_accounts,
            &[seeds] // ← PDA can sign because we have the bump
        ),
        amount
    )?;
}
```

### Reason 4: Cross-Instruction References

```rust
// When one PDA needs to reference another PDA's bump
let related_pda_seeds = &[
    b"related_account",
    current_account.owner.as_ref(),
    &[current_account.bump] // ← Use stored bump for other PDAs
];
```

## The Chicken-and-Egg Problem

### The Problem Statement

1. To **read** the stored bump → Need to access the account
2. To **access** the account → Need to derive its PDA
3. To **derive** the PDA → Need the bump
4. But the bump is **stored in the account** we can't access yet!

### Solution 1: Client Recalculates Bump for Access

```typescript
// Client-side: Calculate PDA to fetch account
const [employeePDA, bump] = PublicKey.findProgramAddressSync(
  [Buffer.from('employee_vesting'), beneficiaryPublicKey.toBuffer(), vestingAccountPublicKey.toBuffer()],
  programId,
)

// Now fetch the account
const employeeAccount = await program.account.employeeAccount.fetch(employeePDA)

// Verify: calculated bump should match stored bump
console.assert(bump === employeeAccount.bump)
```

### Solution 2: Client Tracks Bumps Locally

```typescript
// During account creation, store bump locally
const [employeePDA, bump] = PublicKey.findProgramAddressSync(seeds, programId);

await program.methods
    .createEmployeeVesting(...)
    .accounts({ employeeAccount: employeePDA })
    .rpc();

// Store in local database/storage
await database.saveEmployeeAccount({
    pda: employeePDA.toString(),
    bump: bump,
    beneficiary: beneficiaryPublicKey.toString()
});
```

### Solution 3: Pass Bump as Instruction Parameter

```rust
pub fn claim_tokens(
    ctx: Context<ClaimTokens>,
    bump: u8 // ← Client provides the bump
) -> Result<()> {
    // Validate against stored bump
    require_eq!(bump, ctx.accounts.employee_account.bump, ErrorCode::InvalidBump);

    // Use for signing
    let seeds = &[b"employee_vesting", /* ... */, &[bump]];
    // ... rest of function
}
```

## Bump Grinding Attacks

### Attack Overview

Bump grinding attacks exploit the fact that multiple bumps can generate valid PDAs for the same seeds, allowing attackers to create fake accounts with malicious data.

### Attack Mechanism

```rust
// Legitimate account (canonical bump = 254)
let legitimate_pda = create_program_address(&[seeds, &[254]], program_id);
EmployeeAccount {
    beneficiary: alice_wallet,
    total_amount: 1000,
    total_withdrawn: 500,
    bump: 254,
}

// Attacker's fake account (alternative bump = 251)
let fake_pda = create_program_address(&[seeds, &[251]], program_id);
EmployeeAccount {
    beneficiary: alice_wallet, // Same beneficiary!
    total_amount: 1_000_000,   // Malicious large amount
    total_withdrawn: 0,        // No previous withdrawals
    bump: 251,                 // Different bump
}
```

### Attack Execution

```typescript
// Attacker calls instruction with fake account
await program.methods
  .claimTokens(251) // ← Using alternative bump
  .accounts({
    employeeAccount: fake_pda, // ← Points to fake account
    beneficiary: alice_wallet,
  })
  .rpc()

// Without bump validation: Uses fake account data (1M tokens)
// With bump validation: Rejects because 251 ≠ 254
```

### Attack Vectors

#### Vector 1: Fake Account Creation

```rust
// Vulnerable - doesn't validate bump
pub fn vulnerable_claim(ctx: Context<Claim>, bump: u8) -> Result<()> {
    // ❌ No validation - attacker can use any valid bump
    let seeds = &[b"employee", beneficiary.as_ref(), &[bump]];

    // Uses whatever account the attacker provides
    let amount = ctx.accounts.employee_account.total_amount;

    token::transfer(
        CpiContext::new_with_signer(/* uses fake account data */),
        amount // ❌ Could be malicious amount
    )?;
}
```

#### Vector 2: Authority Confusion

```rust
// Attacker creates account where they control the "owner"
let fake_seeds = &[b"vesting", fake_owner.as_ref(), &[alternative_bump]];
let fake_pda = create_program_address(fake_seeds, program_id);

// Fake account with attacker as owner
VestingAccount {
    owner: attacker_wallet, // ❌ Attacker controls this
    treasury: treasury_with_tokens,
    bump: alternative_bump,
}
```

### Why These Attacks Work

1. **Same Seeds, Different Addresses**: Multiple bumps = multiple valid PDAs
2. **No Canonical Validation**: Program doesn't verify canonical bump
3. **Account Confusion**: Program uses wrong account data
4. **Authority Bypass**: Attacker gains unauthorized control

## Security Best Practices

### 1. Always Store Canonical Bump

```rust
#[account]
pub struct EmployeeAccount {
    // ... other fields
    pub bump: u8, // ← Always store the canonical bump
}

// During initialization
*ctx.accounts.employee_account = EmployeeAccount {
    // ... other fields
    bump: ctx.bumps.employee_account, // ← Anchor guarantees canonical
};
```

### 2. Always Validate Provided Bumps

```rust
pub fn secure_instruction(ctx: Context<SecureContext>, provided_bump: u8) -> Result<()> {
    // ✅ Validate provided bump matches stored canonical bump
    require_eq!(
        provided_bump,
        ctx.accounts.employee_account.bump,
        ErrorCode::InvalidBump
    );

    // Now safe to use the bump
    let seeds = &[b"employee", beneficiary.as_ref(), &[provided_bump]];
    // ...
}
```

### 3. Use Anchor's Automatic Validation

```rust
#[derive(Accounts)]
pub struct SecureContext<'info> {
    #[account(
        seeds = [b"employee", beneficiary.key().as_ref()],
        bump = employee_account.bump // ← Anchor validates automatically
    )]
    pub employee_account: Account<'info, EmployeeAccount>,
}
```

### 4. Implement Custom Error Types

```rust
#[error_code]
pub enum ErrorCode {
    #[msg("Invalid bump provided")]
    InvalidBump,
    #[msg("Account bump mismatch")]
    BumpMismatch,
}
```

### 5. Use Account Constraints for Authorization

```rust
#[account(
    has_one = owner,           // ✅ Verify ownership
    seeds = [b"vesting", company_name.as_ref()],
    bump = vesting_account.bump // ✅ Verify canonical bump
)]
pub vesting_account: Account<'info, VestingAccount>,
```

## Implementation Patterns

### Pattern 1: Account Creation with Bump Storage

```rust
pub fn create_account(ctx: Context<CreateAccount>, name: String) -> Result<()> {
    *ctx.accounts.my_account = MyAccount {
        owner: ctx.accounts.signer.key(),
        name,
        bump: ctx.bumps.my_account, // ← Store canonical bump
    };
    Ok(())
}

#[derive(Accounts)]
#[instruction(name: String)]
pub struct CreateAccount<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + MyAccount::INIT_SPACE,
        seeds = [name.as_ref()],
        bump // ← Anchor finds canonical bump
    )]
    pub my_account: Account<'info, MyAccount>,
    // ...
}
```

### Pattern 2: Account Access with Bump Validation

```rust
pub fn use_account(ctx: Context<UseAccount>, bump: u8) -> Result<()> {
    // ✅ Validate bump
    require_eq!(bump, ctx.accounts.my_account.bump, ErrorCode::InvalidBump);

    // ✅ Safe to use for signing
    let seeds = &[
        ctx.accounts.my_account.name.as_ref(),
        &[bump]
    ];

    // Use seeds for CPI signing...
    Ok(())
}

#[derive(Accounts)]
pub struct UseAccount<'info> {
    #[account(
        mut,
        seeds = [my_account.name.as_ref()],
        bump = my_account.bump // ← Anchor validates automatically
    )]
    pub my_account: Account<'info, MyAccount>,
}
```

### Pattern 3: Client-Side PDA Derivation

```typescript
// TypeScript client pattern
class PDAccountManager {
  async createAccount(name: string) {
    // Calculate PDA
    const [pda, bump] = PublicKey.findProgramAddressSync([Buffer.from(name)], this.programId)

    // Create account
    await this.program.methods.createAccount(name).accounts({ myAccount: pda }).rpc()

    // Store bump for later use
    this.storeBump(name, bump)

    return { pda, bump }
  }

  async useAccount(name: string) {
    // Retrieve stored bump
    const bump = this.getBump(name)

    // Derive PDA
    const [pda] = PublicKey.findProgramAddressSync([Buffer.from(name)], this.programId)

    // Call instruction with bump
    await this.program.methods.useAccount(bump).accounts({ myAccount: pda }).rpc()
  }
}
```

## Common Pitfalls and Solutions

### Pitfall 1: Not Storing Bumps

```rust
// ❌ BAD: No bump stored
#[account]
pub struct BadAccount {
    pub owner: Pubkey,
    pub data: String,
    // Missing bump field!
}

// ✅ GOOD: Bump stored
#[account]
pub struct GoodAccount {
    pub owner: Pubkey,
    pub data: String,
    pub bump: u8, // ← Always include bump
}
```

### Pitfall 2: Not Validating Provided Bumps

```rust
// ❌ BAD: No bump validation
pub fn bad_function(ctx: Context<MyContext>, bump: u8) -> Result<()> {
    let seeds = &[b"account", &[bump]]; // ❌ Uses any bump
    // ... dangerous operations
}

// ✅ GOOD: Bump validation
pub fn good_function(ctx: Context<MyContext>, bump: u8) -> Result<()> {
    require_eq!(bump, ctx.accounts.my_account.bump, ErrorCode::InvalidBump);
    let seeds = &[b"account", &[bump]]; // ✅ Uses validated bump
    // ... safe operations
}
```

### Pitfall 3: Manual Bump Calculation in Constraints

```rust
// ❌ BAD: Manual bump in constraints
#[account(
    seeds = [b"account", owner.key().as_ref()],
    bump = 254 // ❌ Hardcoded bump - security risk!
)]

// ✅ GOOD: Use stored bump
#[account(
    seeds = [b"account", owner.key().as_ref()],
    bump = my_account.bump // ✅ Use stored canonical bump
)]
```

### Pitfall 4: Ignoring Client-Side Bump Management

```typescript
// ❌ BAD: Recalculating bump every time
async function claimTokens() {
  const [pda, bump] = PublicKey.findProgramAddressSync(seeds, programId)
  // Expensive calculation every time
}

// ✅ GOOD: Cache and reuse bumps
class TokenVesting {
  private bumpCache = new Map<string, number>()

  async claimTokens(beneficiary: PublicKey) {
    const cacheKey = beneficiary.toString()
    let bump = this.bumpCache.get(cacheKey)

    if (!bump) {
      ;[, bump] = PublicKey.findProgramAddressSync(seeds, this.programId)
      this.bumpCache.set(cacheKey, bump)
    }

    // Use cached bump
  }
}
```

## Real-World Examples

### Example 1: Token Vesting System

```rust
// Vesting account with stored bumps
#[account]
pub struct VestingAccount {
    pub owner: Pubkey,
    pub mint: Pubkey,
    pub treasury_token_account: Pubkey,
    pub company_name: String,
    pub treasury_bump: u8,  // ← Treasury PDA bump
    pub bump: u8,           // ← Vesting account PDA bump
}

// Employee account with stored bump
#[account]
pub struct EmployeeAccount {
    pub beneficiary: Pubkey,
    pub vesting_account: Pubkey,
    pub total_amount: u64,
    pub bump: u8,           // ← Employee account PDA bump
}

// Secure claim function
pub fn claim_tokens(ctx: Context<ClaimTokens>, bump: u8) -> Result<()> {
    // Validate bump
    require_eq!(bump, ctx.accounts.employee_account.bump, ErrorCode::InvalidBump);

    // Use for treasury signing
    let treasury_seeds = &[
        b"vesting_treasury",
        ctx.accounts.vesting_account.company_name.as_ref(),
        &[ctx.accounts.vesting_account.treasury_bump]
    ];

    // Secure token transfer
    token::transfer(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            transfer_accounts,
            &[treasury_seeds]
        ),
        claimable_amount
    )?;
}
```

### Example 2: DAO Governance System

```rust
#[account]
pub struct Proposal {
    pub dao: Pubkey,
    pub creator: Pubkey,
    pub proposal_id: u64,
    pub bump: u8,
}

#[account]
pub struct Vote {
    pub proposal: Pubkey,
    pub voter: Pubkey,
    pub vote_type: VoteType,
    pub bump: u8,
}

// Creating proposal with bump storage
pub fn create_proposal(ctx: Context<CreateProposal>, proposal_id: u64) -> Result<()> {
    *ctx.accounts.proposal = Proposal {
        dao: ctx.accounts.dao.key(),
        creator: ctx.accounts.creator.key(),
        proposal_id,
        bump: ctx.bumps.proposal,
    };
}

// Voting with bump validation
pub fn vote(ctx: Context<Vote>, vote_bump: u8, vote_type: VoteType) -> Result<()> {
    require_eq!(vote_bump, ctx.accounts.vote_account.bump, ErrorCode::InvalidBump);

    // Safe to proceed with voting logic
    ctx.accounts.vote_account.vote_type = vote_type;
}
```

### Example 3: Client-Side Integration

```typescript
export class VestingClient {
  private program: Program<TokenVesting>
  private bumpCache = new Map<string, number>()

  // Create vesting account
  async createVestingAccount(companyName: string): Promise<PublicKey> {
    const [vestingPDA, vestingBump] = PublicKey.findProgramAddressSync(
      [Buffer.from(companyName)],
      this.program.programId,
    )

    const [treasuryPDA, treasuryBump] = PublicKey.findProgramAddressSync(
      [Buffer.from('vesting_treasury'), Buffer.from(companyName)],
      this.program.programId,
    )

    await this.program.methods
      .createVestingAccount(companyName)
      .accounts({
        vestingAccount: vestingPDA,
        treasuryTokenAccount: treasuryPDA,
        // ... other accounts
      })
      .rpc()

    // Cache bumps for later use
    this.bumpCache.set(`vesting_${companyName}`, vestingBump)
    this.bumpCache.set(`treasury_${companyName}`, treasuryBump)

    return vestingPDA
  }

  // Create employee vesting
  async createEmployeeVesting(
    beneficiary: PublicKey,
    vestingAccount: PublicKey,
    schedule: VestingSchedule,
  ): Promise<PublicKey> {
    const [employeePDA, employeeBump] = PublicKey.findProgramAddressSync(
      [Buffer.from('employee_vesting'), beneficiary.toBuffer(), vestingAccount.toBuffer()],
      this.program.programId,
    )

    await this.program.methods
      .createEmployeeVesting(schedule.startTime, schedule.endTime, schedule.totalAmount, schedule.cliffTime)
      .accounts({
        employeeAccount: employeePDA,
        beneficiary,
        vestingAccount,
        // ... other accounts
      })
      .rpc()

    // Cache employee bump
    const cacheKey = `employee_${beneficiary.toString()}_${vestingAccount.toString()}`
    this.bumpCache.set(cacheKey, employeeBump)

    return employeePDA
  }

  // Claim tokens with cached bump
  async claimTokens(beneficiary: PublicKey, vestingAccount: PublicKey): Promise<void> {
    const cacheKey = `employee_${beneficiary.toString()}_${vestingAccount.toString()}`
    let bump = this.bumpCache.get(cacheKey)

    if (!bump) {
      const [, calculatedBump] = PublicKey.findProgramAddressSync(
        [Buffer.from('employee_vesting'), beneficiary.toBuffer(), vestingAccount.toBuffer()],
        this.program.programId,
      )
      bump = calculatedBump
      this.bumpCache.set(cacheKey, bump)
    }

    const [employeePDA] = PublicKey.findProgramAddressSync(
      [Buffer.from('employee_vesting'), beneficiary.toBuffer(), vestingAccount.toBuffer()],
      this.program.programId,
    )

    await this.program.methods
      .claimTokens(bump)
      .accounts({
        employeeAccount: employeePDA,
        beneficiary,
        // ... other accounts
      })
      .rpc()
  }
}
```

## Summary and Key Takeaways

### Essential Rules for Bump Management

1. **Always Store Canonical Bumps**
   - Include `bump: u8` field in all PDA account structures
   - Use `ctx.bumps.account_name` during initialization
   - Anchor guarantees this is the canonical (highest valid) bump

2. **Always Validate Provided Bumps**
   - Compare provided bumps against stored canonical bumps
   - Use `require_eq!` or similar validation
   - Reject transactions with non-canonical bumps

3. **Use Anchor's Automatic Validation**
   - Leverage `bump = account.bump` in account constraints
   - Let Anchor handle validation automatically
   - Reduces manual validation code and potential errors

4. **Implement Proper Client-Side Management**
   - Cache bumps after account creation
   - Use `findProgramAddressSync` for initial PDA derivation
   - Store bumps in databases or local storage for persistence

5. **Understand the Security Implications**
   - Multiple bumps = multiple valid PDAs = potential attack vector
   - Non-canonical bumps can lead to account confusion attacks
   - Bump validation is critical for preventing fake account usage

### Performance Considerations

- **Account Creation**: Store bump (1 byte cost, significant security benefit)
- **Account Access**: Recalculate bump when needed (acceptable cost)
- **Account Usage**: Pass bump as parameter (most efficient)
- **Client Caching**: Store bumps locally to avoid recalculation

### Security Checklist

- [ ] All PDA accounts include `bump: u8` field
- [ ] Canonical bumps stored during account initialization
- [ ] Provided bumps validated against stored canonical bumps
- [ ] Account constraints use stored bumps for validation
- [ ] Client applications properly cache and manage bumps
- [ ] Custom error types defined for bump validation failures
- [ ] No hardcoded bumps in account constraints
- [ ] Proper seeds used for all PDA derivations

By following these patterns and understanding the underlying mechanics, you can build secure, efficient Solana programs that properly handle PDA bumps and prevent common attack vectors.
